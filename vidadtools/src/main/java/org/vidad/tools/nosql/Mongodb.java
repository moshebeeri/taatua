/**
 * This file was generated by Moshe Beeri
 * Apr 22, 2013
 * com.orbograph.cloudtools.conf
 */
package org.vidad.tools.nosql;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.bson.types.ObjectId;
import org.joda.time.DateTime;
import org.vidad.data.Collectionable;
import org.vidad.tools.conf.Collection;
import org.vidad.tools.conf.Configure;
import org.vidad.tools.conf.Environment;
import org.vidad.tools.conf.Environments;
import org.vidad.tools.conf.MongoConfig;

import com.google.gson.Gson;
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import com.mongodb.Mongo;
import com.mongodb.MongoClient;
import com.mongodb.MongoCredential;
import com.mongodb.ServerAddress;
import com.mongodb.gridfs.GridFS;
import com.mongodb.gridfs.GridFSDBFile;
import com.mongodb.gridfs.GridFSInputFile;
import com.mongodb.util.JSON;

/**
 * @author Moshe Beeri
 * 
 *         BasicDBObject bo = new BasicDBObject(); bo.put("something", new
 *         Byte[]{});
 * 
 */
public class Mongodb implements Serializable{
	private static final long serialVersionUID = 672641262245906040L;
	transient Logger log = Logger.getLogger(Mongodb.class);
	transient Gson gson = new Gson();

	Map<String, DBCollection> collections;

	Environment environment;
	String environmentName;
	MongoConfig mongoConfig;
	Mongo mongo;
	DB db;

	private volatile static Mongodb instance;

	public static Mongodb getInstance() {
		if (instance == null) {
			synchronized (Mongodb.class) {
				if (instance == null) {
					instance = new Mongodb();
				}
			}
		}
		return instance;
	}

	
	/**
	 * @param type
	 * @throws Exception
	 */
	private Mongodb() {
		initialize();
	}

	/**
	 * @throws Exception
	 */
	private void initialize() {
		try{
			environment = getEnvironmentInstance();
			if (environment == null)
				throw new IOException("no environment found");
	
			mongoConfig = environment.getMongoConfig();
			String activeTenantName = Configure.settings().getString("active.tenant");
			String dbName = mongoConfig.isTenanted()? activeTenantName + "_" + mongoConfig.getDbName() : mongoConfig.getDbName();
	
			if (mongoConfig.isAuthenticate()) {
				MongoCredential credential = MongoCredential
						.createMongoCRCredential(mongoConfig.getAdminUser(),
								"admin", mongoConfig.getAdminPassword()
										.toCharArray());
				mongo = new MongoClient(new ServerAddress(mongoConfig.getHost()),
						Arrays.asList(credential));
			} else
				mongo = new MongoClient(mongoConfig.getHost());
	
			List<String> databaseNames = mongo.getDatabaseNames();
			Set<String> dbsSet = new HashSet<String>(databaseNames);
			if (dbsSet.contains(dbName)) {
				db = mongo.getDB(dbName);
				authenticateUserIfNeeded(dbName);
			} else {
				db = createDB(dbName);
			}
	
			collections = new HashMap<String, DBCollection>();
	
			for (Collection c : Collection.all()) {
				String collectionName = c.name();
				DBCollection collection = db.getCollection(collectionName);
				collections.put(collectionName, collection);
				// keep for example
				// collection.ensureIndex(new BasicDBObject("context.type", 1));
			}
		}catch(Exception e){
		
		}
	}

	/**
	 * Authenticate user if needed 
	 * @param dbName
	 * @throws Exception thrones in case there is a need to authenticate and authentication failed. 
	 */
	private void authenticateUserIfNeeded(String dbName) throws Exception {
		if (mongoConfig.isAuthenticate() && 
				!db.authenticate(mongoConfig.getUser(), mongoConfig.getPassword().toCharArray()))
			throw new Exception("Authentication failure to mongodb at "
					+ mongoConfig.getHost() + " db " + dbName
					+ " user: " + mongoConfig.getUser() + " password:"
					+ mongoConfig.getPassword());
	}

	/**
	 * @param dbName
	 * @return
	 */
	private DB createDB(String dbName) {
		DB db = mongo.getDB(dbName);
		if (mongoConfig.isAuthenticate()) {
			String user = mongoConfig.getUser();
			String password = mongoConfig.getPassword();
			db.addUser(user, password.toCharArray());
			log.info("creating tenanted DB " + dbName + " for " + user
					+ "@" + mongoConfig.getHost() + " with password "
					+ password);
		}
		return db;
	}

	/**
	 * @return
	 * @throws Exception
	 */
	public Environment getEnvironmentInstance() throws Exception {
		return Environments.getInstance().getEnvironment();
	}

	/**
	 * @param id
	 * @param collection
	 * @param clazz
	 * @return
	 * @throws ClassNotFoundException
	 */
	public <T extends Collectionable<?>> T getCollectionable(ObjectId id,
			Collection collection, Class<T> clazz) {
		return getObject(id, collections.get(collection.name()), clazz);
	}

	/**
	 * @param id
	 * @param collection
	 * @param clazz
	 * @return
	 */
	public <T extends Collectionable<?>> List<T> getAllCollectionable(
			Collection collection, Class<T> clazz) {
		return getAllObjects(collections.get(collection.name()), clazz);
	}
	
	/**
	 * @param id
	 * @param collection
	 * @param clazz
	 * @return
	 */
	public <T extends Collectionable<?>> List<T> getFromTimeCollectionable(
			DateTime from, Collection collection, Class<T> clazz) {
		return queryObjectsFromTime(from,
				collections.get(collection.name()), clazz);
	}

	/**
	 * @param collectionable
	 * @param collection
	 * @return
	 */
	public ObjectId insertCollectionable(Collectionable<?> collectionable) {
		ObjectId id =  insertObjectToCollection(
						collections.get(collectionable.getCollection().name()),
						collectionable);
		//Save object id 
		collectionable.setObjectId(id);
		updateCollectionable(collectionable);
		return id;
	}

	/**
	 * @param collectionable
	 * @return
	 */
	public ObjectId updateCollectionable(Collectionable<?> collectionable) {
		return updateObjectToCollection(
				collections.get(collectionable.getCollection().name()),
				collectionable.getObjectId(), collectionable);
	}

	/**
	 * @param collectionable
	 * @throws IOException
	 */
	public <T extends Collectionable<?>> T deleteCollectionable(ObjectId id,
			Collection collection, Class<T> clazz) {
		return deleteObject(id, collections.get(collection.name()), clazz);
	}

	/**
	 * @param collectionable
	 */
	public <T extends Collectionable<?>> List<T> queryCollectionable(
			String path, String value, Collection collection, Class<T> clazz) {
		return queryObjects(path, value, collections.get(collection.name()),
				clazz);
	}

	/**
	 * @param pageNumber 
	 * @param nPerPage 
	 * @param collectionable
	 */
	public <T extends Collectionable<?>> List<T> queryCollectionablePaged(
			BasicDBObject query, Collection collection, Class<T> clazz, int pageNumber, int nPerPage) {
		DBCollection dbCollection = collections.get(collection.name());
		DBCursor cursor = dbCollection.find(query).skip((pageNumber-1)*nPerPage).limit(nPerPage);
		List<T> ret = new ArrayList<T>();
		while (cursor.hasNext()) {
			String className = clazz.getSimpleName().toLowerCase();
			DBObject next = cursor.next();
			T t = gson.fromJson(next.get(className).toString(), clazz);
			ret.add(t);
		}
		return ret;
	}	

	/**
	 * @param collection
	 * @param jsnoStream
	 * @return
	 */
	public ObjectId insertObjectToCollection(DBCollection collection,
			Collectionable<?> jsnoStream) {
		String json = jsnoStream.toJson();
		DBObject dbo = (DBObject) JSON.parse(json);
		String className = jsnoStream.getClass().getSimpleName().toLowerCase();
		return insertJsonIntoCollection(collection, dbo, className);
	}

	/**
	 * @param collection
	 * @param dbo
	 * @param className
	 * @return
	 */
	public ObjectId insertJsonIntoCollection(DBCollection collection,
			DBObject dbo, String className) {
		BasicDBObject obj = new BasicDBObject(className, dbo);
		collection.save(obj);
		return (ObjectId) obj.get("_id");
	}

	/**
	 * @param collection
	 * @param _id
	 * @param jsnoStrem
	 * @return
	 */
	private ObjectId updateObjectToCollection(DBCollection collection,
			ObjectId _id, Collectionable<?> jsnoStrem){
		BasicDBObject query = new BasicDBObject();
		query.put("_id", _id);
		DBObject dbo = (DBObject) JSON.parse(jsnoStrem.toJson());
		BasicDBObject obj = new BasicDBObject(jsnoStrem.getClass()
				.getSimpleName().toLowerCase(), dbo);
		collection.update(query, obj);
		return (ObjectId) obj.get("_id");
	}

	/**
	 * @param collection
	 * @param clazz
	 * @return
	 */
	public <T extends Collectionable<?>> List<T> getAllObjects(
			DBCollection collection, Class<T> clazz){
		DBCollection dbc = collections.get(collection.getName());
		BasicDBObject query = new BasicDBObject();
		DBCursor cursor = dbc.find(query);
		List<T> ret = new ArrayList<T>();
		while (cursor.hasNext()) {
			String className = clazz.getSimpleName().toLowerCase();
			DBObject next = cursor.next();
			T t = gson.fromJson(next.get(className).toString(), clazz);
			ret.add(t);
		}
		return ret;
	}

	/**
	 * @param _id
	 * @param collection
	 * @param clazz
	 */
	public <T extends Collectionable<?>> T getObject(ObjectId _id,
			DBCollection collection, Class<T> clazz) {
		BasicDBObject query = new BasicDBObject();
		query.put("_id", _id);
		// Should be only one
		DBObject dbo = collection.findOne(query);
		String className = clazz.getSimpleName().toLowerCase();
		T t = gson.fromJson(dbo.get(className).toString(), clazz);
		return t;
	}

	/**
	 * @param _id
	 * @param collection
	 * @param clazz
	 *            - if not null, the deleted object is returned
	 * @return
	 */
	public <T extends Collectionable<?>> T deleteObject(ObjectId _id,
			DBCollection collection, Class<T> clazz) {
		BasicDBObject query = new BasicDBObject();
		query.put("_id", _id);
		// Should be only one
		DBObject dbo = collection.findOne(query);
		T ret = clazz == null ? null : gson.fromJson(
				dbo.get(clazz.getSimpleName().toLowerCase()).toString(), clazz);
		collection.remove(dbo);
		return ret;
	}

	/**
	 * Provides simple one field match query
	 * 
	 * @param path
	 * @param value
	 * @param collection
	 * @param clazz
	 * @return
	 */
	public <T extends Collectionable<?>> List<T> queryObjects(String path,
			String value, DBCollection collection, Class<T> clazz) {
		BasicDBObject query = new BasicDBObject();
		query.put(path, value);
		return queryObjects(collection, clazz, query);
	}

	/**
	 * @param collection
	 * @param clazz
	 * @param query
	 * @return
	 */
	public <T extends Collectionable<?>> List<T> queryObjects(
			Collection collection, Class<T> clazz, BasicDBObject query) {
		return queryObjects(collections.get(collection.name()),clazz, query);
				
	}
	
	
	/**
	 * @param collection
	 * @param clazz
	 * @param query
	 * @return
	 */
	private <T extends Collectionable<?>> List<T> queryObjects(
			DBCollection collection, Class<T> clazz, BasicDBObject query) {
		DBCursor cursor = collection.find(query);
		List<T> ret = new ArrayList<T>();
		while (cursor.hasNext()) {
			String className = clazz.getSimpleName().toLowerCase();
			DBObject next = cursor.next();
			T t = gson.fromJson(next.get(className).toString(), clazz);
			ret.add(t);
		}
		return ret;
	}

	/**
	 * @see http 
	 *      ://stackoverflow.com/questions/8749971/can-i-query-mongodb-objectid
	 *      -by-date
	 * @see http://www.mkyong.com/mongodb/java-mongodb-query-document/
	 * 
	 * @param from
	 *            - the time you'd like to get infor from
	 * @param collection
	 *            - the collection
	 * @param clazz
	 *            - the type to convert to
	 * 
	 *            pattern example { _id: { $gt:
	 *            objectIdWithTimestamp('1980/05/25') } }
	 * 
	 * @return
	 */
	public <T extends Collectionable<?>> List<T> queryObjectsFromTime(
			DateTime from, DBCollection collection, Class<T> clazz) {
		BasicDBObject query = new BasicDBObject();
		long unixTime = from.getMillis() / 1000;
		String hexSeconds = Long.toHexString(unixTime);
		// Create an ObjectId with that hex timestamp
		ObjectId fromObjectId = new ObjectId(hexSeconds + "0000000000000000");

		query.put("_id", new BasicDBObject("$gt", fromObjectId));
		DBCursor cursor = collection.find(query);
		List<T> ret = new ArrayList<T>();
		while (cursor.hasNext()) {
			String className = clazz.getSimpleName().toLowerCase();
			DBObject next = cursor.next();
			T t = gson.fromJson(next.get(className).toString(), clazz);
			ret.add(t);
		}
		return ret;
	}

	/**
	 * @param in
	 * @param name
	 * @param collectionName
	 * @return
	 */
	public ObjectId insertStreamToCollection(InputStream in, String name,
			String collectionName) {

		GridFS originals = new GridFS(db, collectionName);
		GridFSInputFile pdfFile = originals.createFile(in, name);
		pdfFile.save();
		return (ObjectId) pdfFile.get("_id");
	}

	/**
	 * @param _id
	 * @param out
	 * @param collectionName
	 * @return
	 */
	public OutputStream getStreamFromCollection(ObjectId _id, OutputStream out,
			String collectionName)  {
		GridFSDBFile imageForOutput = getGridFSDBFile(_id, collectionName);
		try {
			imageForOutput.writeTo(out);
		} catch (IOException e) {
			log.error(e.getMessage());
			e.printStackTrace();
		}
		return out;
	}

	/**
	 * @param _id
	 * @param collectionName
	 * @return
	 */
	public GridFSDBFile getGridFSDBFile(ObjectId _id, String collectionName) {
		BasicDBObject query = new BasicDBObject();
		query.put("_id", _id);

		GridFS gfs = new GridFS(db, collectionName);
		GridFSDBFile imageForOutput = gfs.findOne(query);
		return imageForOutput;
	}

	public void deleteStreamFromCollection(ObjectId _id, String collectionName) {
		BasicDBObject query = new BasicDBObject();
		query.put("_id", _id);

		GridFS gfs = new GridFS(db, collectionName);
		GridFSDBFile imageForDeletion = gfs.findOne(query);
		gfs.remove(imageForDeletion);
	}

	/**
	 * @param unittest
	 */
	public void dropCollection(Collection collection) {
		collections.get(collection.name()).drop();
	}
}
